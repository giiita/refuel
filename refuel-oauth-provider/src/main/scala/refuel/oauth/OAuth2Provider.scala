package refuel.oauth

import akka.http.scaladsl.marshalling.ToResponseMarshallable
import akka.http.scaladsl.server.{Directive1, Directives}
import refuel.injector.AutoInject
import refuel.oauth.authorize.{AuthProfile, AuthorizeCode, AuthorizeRequest}
import refuel.oauth.endpoint.{AuthorizeEndpoint, TokenEndpoint}
import refuel.oauth.grant.GrantHandler
import refuel.oauth.token.AccessToken

trait OAuth2Provider[F[_], U] extends Directives with AutoInject {
  protected val authorize: AuthorizeEndpoint[F]
  protected val token: TokenEndpoint[F]
  protected val grantHandler: GrantHandler[F, U]

  /** Authorize step 1 (Authorize code grant / Implicit grant)
    *
    * Minimally inspect authorization requests.
    *
    * When an invalid authorization request is detected, if we know the redirect endpoint of
    * the service provider, we will redirect complete with an error code, but if we don't know
    * it, this endpoint will respond with an abnormal value such as 401.
    *
    * It is a directive that only checks the legitimacy of the authorization request. After this, it is
    * necessary to check any authentication and authorization information and redirect to the authorization screen
    * of the authorization server or to the redirect uri of the service provider, if necessary.
    *
    * Since the specific authentication and authorization algorithms from here on are not strictly
    * defined in OAuth2.0, an original implementation is required. However, it is possible to use `AAA` for
    * the redirect to the service provider after the authorization is completed.
    *
    */
  def authorizeRequest: Directive1[AuthorizeRequest] = parameterMap.flatMap { authorizeRequest }
  def authorizeRequest(param: Map[String, String]): Directive1[AuthorizeRequest] =
    authorize.validAuthorizeRequest(param, grantHandler)

  /** Authorization step 1 - [[authorizeRequest]]
    * Authorization step 2 (final)
    *
    * When the authorization is complete, the authorization request has been stored, and the authorization code
    * has been issued, the service provider must be notified of the authorization code.
    *
    * {{{
    *   path("authorize_endpoint") {
    *     validAuthorizeRequest { req =>
    *       grantAndIssueCode { code =>
    *         authorizeComplete(req, code)
    *       }
    *     }
    *   }
    * }}}
    *
    * @param request Valid authorization request
    * @param authorizeCode Issued authorize code.
    * @return
    */
  def authorizeCodeComplete(request: AuthorizeRequest, authorizeCode: AuthorizeCode): ToResponseMarshallable =
    authorize.authorizeComplete(request, authorizeCode)

  /** Implicit grant step 1 - [[authorizeRequest]]
    * Implicit grant step 2
    *
    * With implicit grant, there is no need to generate an authorization code.
    * After validating the authorization request, the redirect uri is sent with an access token.
    *
    * @param request
    * @param accessToken
    * @return
    */
  @deprecated("Since OAuth2.1, this specification seems to disappear.")
  def implicitGrantComplete(request: AuthorizeRequest, accessToken: AccessToken): ToResponseMarshallable =
    authorize.implicitGrantComplete(request, accessToken)

  /** Token generation step 1
    *
    * Validates the authorization code and verifies that it is a proper authorization code.
    * Since this directive completes the verification flow defined in OAuth2.0, apply performs
    * the additional necessary verification and issues the access token.
    *
    * Since the algorithm for generating authorization codes and access tokens is not defined
    * in OAuth2.0, it is necessary to implement it independently, and in the process, it may be
    * necessary to persist stateful authorization codes etc...
    *
    * @return
    */
  def grantRequest: Directive1[AuthProfile[U]] = token.grant(grantHandler)

  /** Token generation step 1 - [[grantRequest]]
    * Token generation step 2
    *
    * Sends an AccessToken generated by its own algorithm to the client.
    * The client sends this as an authentication header to the protected endpoint
    * according to TokenType, and can then access the protected resource.
    *
    * @param token Access token
    */
  def issue(token: AccessToken): ToResponseMarshallable = token
}
